//go:build integration

package refresh_test

import (
	"context"
	"fmt"
	"math/rand"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.uber.org/zap"

	"github.com/alexgrauroca/practice-food-delivery-platform/services/authentication-service/internal/clock"
	"github.com/alexgrauroca/practice-food-delivery-platform/services/authentication-service/internal/config"
	"github.com/alexgrauroca/practice-food-delivery-platform/services/authentication-service/internal/refresh"
)

var now = time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)
var expiresAt = time.Date(2025, 1, 7, 0, 0, 0, 0, time.UTC)

func TestRepository_Create(t *testing.T) {
	tests := []struct {
		name          string
		params        refresh.CreateTokenParams
		expectedToken refresh.Token
		expectedError error
	}{
		{
			name: "when the refresh token is stored successfully, it should return the stored token",
			params: refresh.CreateTokenParams{
				UserID:    "fake-user-id",
				Role:      "fake-role",
				Token:     "fake-token",
				ExpiresAt: expiresAt,
			},
			expectedToken: refresh.Token{
				UserID:    "fake-user-id",
				Role:      "fake-role",
				Token:     "fake-token",
				Status:    refresh.TokenStatusActive,
				ExpiresAt: expiresAt,
				CreatedAt: now,
				UpdatedAt: now,
			},
			expectedError: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db, cleanup := setupTestDB(t)
			defer cleanup()

			repo := refresh.NewRepository(zap.NewNop(), db, clock.FixedClock{FixedTime: now})
			token, err := repo.Create(context.Background(), tt.params)

			// Error assertion
			assert.ErrorIs(t, err, tt.expectedError)

			// Validating the token only if there is no error expected
			if tt.expectedError == nil {
				// Checking the expected fields that can be predicted
				assert.Equal(t, tt.expectedToken.UserID, token.UserID, "UserID should match the expected value")
				assert.Equal(t, tt.expectedToken.Role, token.Role, "Role should match the expected value")
				assert.Equal(t, tt.expectedToken.Token, token.Token, "Token should match the expected value")
				assert.Equal(t, tt.expectedToken.Status, token.Status, "Status should match the expected value")
				assert.Equal(t, tt.expectedToken.ExpiresAt, token.ExpiresAt, "ExpiresAt should match the expected value")
				assert.Equal(t, tt.expectedToken.CreatedAt, token.CreatedAt, "CreatedAt should match the expected value")
				assert.Equal(t, tt.expectedToken.UpdatedAt, token.UpdatedAt, "UpdatedAt should match the expected value")

				// As the ID is generated by MongoDB, we just check that it is not empty
				assert.NotEmpty(t, token.ID, "ID should not be empty")
			}
		})
	}
}

func TestRepository_Create_UnexpectedFailure(t *testing.T) {
	db, cleanup := setupTestDB(t)
	repo := refresh.NewRepository(zap.NewNop(), db, clock.FixedClock{FixedTime: now})

	// Simulating an unexpected failure by closing the opened connection
	cleanup()

	_, err := repo.Create(context.Background(), refresh.CreateTokenParams{})
	assert.Error(t, err, "Expected an error due to unexpected failure")
}

// TODO review how to handle this duplication in multiple integration tests
func setupTestDB(t *testing.T) (*mongo.Database, func()) {
	logger := zap.NewNop()
	mongoCfg, err := config.LoadMongoConfig(logger)
	if err != nil {
		t.Fatalf("Failed to load MongoDB configuration: %v", err)
	}

	clientOpts := options.Client().ApplyURI(mongoCfg.URI)
	if mongoCfg.User != "" && mongoCfg.Password != "" {
		clientOpts.SetAuth(options.Credential{
			Username: mongoCfg.User,
			Password: mongoCfg.Password,
		})
	}

	// Context with timeout for connection
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	client, err := mongo.Connect(ctx, clientOpts)
	if err != nil {
		t.Fatalf("Failed to connect to MongoDB: %v", err)
	}
	// Setting up a unique database name for each test to avoid conflicts
	dbName := fmt.Sprintf("customers_test_authentication_service_%d_%d", time.Now().UnixNano(), rand.Intn(10000))
	db := client.Database(dbName)
	cleanup := func() {
		if err := db.Drop(ctx); err != nil {
			t.Fatalf("Failed to drop MongoDB collection: %v", err)
			return
		}
		if err := client.Disconnect(ctx); err != nil {
			t.Fatalf("Failed to disconnect MongoDB client: %v", err)
			return
		}
		cancel()
	}
	return db, cleanup
}
