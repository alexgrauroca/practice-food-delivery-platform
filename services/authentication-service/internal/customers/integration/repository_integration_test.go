//go:build integration

package integration

import (
	"context"
	"testing"
	"time"

	"github.com/alexgrauroca/practice-food-delivery-platform/services/authentication-service/internal/clock"
	"github.com/alexgrauroca/practice-food-delivery-platform/services/authentication-service/internal/customers"
	"github.com/stretchr/testify/assert"
	"go.mongodb.org/mongo-driver/mongo"
	"go.uber.org/zap"
)

func TestRepository_CreateCustomer(t *testing.T) {
	now := time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)

	tests := []struct {
		name             string
		insertDocuments  func(t *testing.T, coll *mongo.Collection)
		params           customers.CreateCustomerParams
		expectedCustomer customers.Customer
		expectedError    error
	}{
		{
			name: "when exists an active customer with the same email, it should return a customer already exists error",
			insertDocuments: func(t *testing.T, coll *mongo.Collection) {
				insertTestCustomer(t, coll, "test@example.com", "John Doe", "fakehashedpassword", true)
			},
			params: customers.CreateCustomerParams{
				Email:    "test@example.com",
				Password: "ValidPassword123",
				Name:     "John Doe",
			},
			expectedCustomer: customers.Customer{},
			expectedError:    customers.ErrCustomerAlreadyExists,
		},
		{
			name: "when the customer is created successfully, it should return the created customer",
			params: customers.CreateCustomerParams{
				Email:    "test@example.com",
				Password: "ValidPassword123",
				Name:     "John Doe",
			},
			expectedCustomer: customers.Customer{
				Email:     "test@example.com",
				Name:      "John Doe",
				Active:    true,
				Password:  "ValidPassword123",
				CreatedAt: now,
				UpdatedAt: now,
			},
			expectedError: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db, cleanup := setupTestDB(t)
			defer cleanup()

			coll := setupTestCustomersCollection(t, db)
			if tt.insertDocuments != nil {
				tt.insertDocuments(t, coll)
			}

			repo := customers.NewRepository(zap.NewNop(), db, clock.FixedClock{FixedTime: now})
			customer, err := repo.CreateCustomer(context.Background(), tt.params)

			// Error assertion
			assert.ErrorIs(t, err, tt.expectedError)

			// Validating the customer only if there is no error expected
			if tt.expectedError == nil {
				// Checking the expected fields that can be predicted
				assert.Equal(t, tt.expectedCustomer.Email, customer.Email, "Email should match the expected value")
				assert.Equal(t, tt.expectedCustomer.Name, customer.Name, "Name should match the expected value")
				assert.Equal(t, tt.expectedCustomer.Active, customer.Active, "Active status should match the expected value")
				assert.Equal(t, tt.expectedCustomer.Password, customer.Password, "Password should match the expected value")
				assert.Equal(t, tt.expectedCustomer.CreatedAt, customer.CreatedAt, "CreatedAt should match the expected value")
				assert.Equal(t, tt.expectedCustomer.UpdatedAt, customer.UpdatedAt, "UpdatedAt should match the expected value")

				// As the ID is generated by MongoDB, we just check that it is not empty
				assert.NotEmpty(t, customer.ID, "ID should not be empty")
			}
		})
	}
}

func TestRepository_CreateCustomer_UnexpectedFailure(t *testing.T) {
	db, cleanup := setupTestDB(t)

	now := time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)
	repo := customers.NewRepository(zap.NewNop(), db, clock.FixedClock{FixedTime: now})

	// Simulating an unexpected failure by closing the opened connection
	cleanup()

	_, err := repo.CreateCustomer(context.Background(), customers.CreateCustomerParams{})
	//TODO ensure the error is not one of the controlled errors
	assert.Error(t, err, "Expected an error due to unexpected failure")
}
